"""
Service layer for Writing Practice module
"""

from typing import List, Optional
from sqlalchemy.orm import Session
from sqlalchemy import desc
from src.writing.models import WritingSession, WritingChatMessage, SessionStatus, CEFRLevel
from src.writing.schemas import (
    WritingSessionCreate, 
    WritingSessionResponse, 
    WritingSessionListResponse,
    ChatMessageCreate, 
    ChatMessageResponse, 
    HintResponse, 
    FinalEvaluationResponse
)
from src.writing.agents.text_generator_agent.agent import text_generator_agent
from src.writing.agents.hint_provider_agent.agent import hint_provider_agent
from src.writing.agents.final_evaluator_agent.agent import final_evaluator_agent
from src.writing.agents.chat_writing_agent.agent import chat_writing_agent
from google.adk.runners import Runner
from google.adk.sessions import DatabaseSessionService
from google.genai import types
from datetime import datetime
import json
from src.config import get_database_url
from src.utils.agent_utils import call_agent_with_logging
import logging
import random
from fastapi import HTTPException

# Constants
SESSION_NOT_FOUND_MSG = "Không tìm thấy phiên luyện viết"

# Logger for writing service
logger = logging.getLogger(__name__)

class WritingService:
    def __init__(self):
        # Use application DB config so ADK session tables live in the same PostgreSQL database
        self.session_service = DatabaseSessionService(db_url=get_database_url())
    
    async def create_writing_session(
        self, 
        user_id: int, 
        session_data: WritingSessionCreate, 
        db: Session
    ) -> WritingSessionResponse:
        """Create a new writing practice session"""
        try:
            # Create database session
            db_session = WritingSession(
                user_id=user_id,
                topic=session_data.topic,
                level=session_data.level,
                total_sentences=session_data.total_sentences,
                vietnamese_sentences=[],  # Will be generated by agent
                status=SessionStatus.ACTIVE
            )
            
            db.add(db_session)
            db.commit()
            db.refresh(db_session)
            
            # Initialize agent session
            # Note: vietnamese_sentences will be created by agent's output_key when it runs
            await self.session_service.create_session(
                app_name="WritingPractice",
                user_id=str(user_id),
                session_id=str(db_session.id),
                state={
                    "session_id": db_session.id,
                    "topic": session_data.topic,
                    "level": session_data.level.value,
                    "total_sentences": session_data.total_sentences,
                    "current_sentence_index": 0,
                    "evaluation_history": [],
                    "hint_history": {},
                    "vietnamese_sentences": {}
                }
            )
            
            # Generate Vietnamese text using the dedicated generator agent
            runner = Runner(
                agent=text_generator_agent,
                app_name="WritingPractice",
                session_service=self.session_service
            )
            generated_text = None
            sentences = None
            # Run agent to generate text with logging
            try:
                # Ask agent to generate using values in session state (topic/level/total_sentences)
                query = "Generate Vietnamese text using session state."
                
                # call_agent_with_logging returns final_response_text (string), NOT the structured dict
                # The structured output (dict) is automatically stored in state by ADK via output_key
                # We don't need the response text, only the structured output in state
                await call_agent_with_logging(
                    runner=runner,
                    user_id=str(user_id),
                    session_id=str(db_session.id),
                    query=query,
                    logger=logger
                )
                
                # Get structured output from agent session state (ADK stores it automatically)
                # Note: We read from state, NOT from response_text (which is just a string)
                try:
                    agent_session = await self.session_service.get_session(
                        app_name="WritingPractice",
                        user_id=str(user_id),
                        session_id=str(db_session.id)
                    )
                    
                    # Agent has output_key="vietnamese_sentences", so ADK automatically creates this key
                    # and stores the dict {full_text: "...", sentences: [...]} in state after agent runs
                    # We keep vietnamese_sentences as-is in state (no normalization needed)
                    vietnamese_sentences_data = agent_session.state.get("vietnamese_sentences", {})
                    if not isinstance(vietnamese_sentences_data, dict) or not vietnamese_sentences_data:
                        raise ValueError("AI text generation failed: No structured output from agent")
                    generated_text = vietnamese_sentences_data.get("full_text", "")
                    sentences = vietnamese_sentences_data.get("sentences", [])

                except Exception as e:
                    print(f"Error getting structured output: {e}")
                    raise ValueError(f"AI text generation failed: {str(e)}")

            except Exception as agent_error:
                print(f"Agent error: {agent_error}")
                import traceback
                traceback.print_exc()
                # Raise error instead of using fallback
                raise ValueError(f"AI text generation failed: {str(agent_error)}")
            
            # Validate that we have sentences
            if not sentences or not isinstance(sentences, list) or len(sentences) == 0:
                raise ValueError("AI text generation failed: No sentences generated")
            
            if not generated_text:
                raise ValueError("AI text generation failed: No text generated")
            
            # Update database with generated sentences
            db_session.vietnamese_sentences = sentences
            db.commit()
            
            # create first assistant message (randomized prompt)
            prompt_templates = [
                "Hãy dịch câu tiếng Việt này sang tiếng Anh: {sentence}",
                "Dịch sang tiếng Anh câu sau: {sentence}",
                "Bạn hãy viết bản dịch tiếng Anh cho câu: {sentence}",
                "Hãy thử dịch câu này sang tiếng Anh: {sentence}",
            ]
            first_sentence = sentences[0]
            assistant_prompt = random.choice(prompt_templates).format(sentence=first_sentence)
            assistant_message = WritingChatMessage(
                session_id=db_session.id,
                role="assistant",
                content=assistant_prompt,
                sentence_index=0
            )
            db.add(assistant_message)
            db.commit()
            
            # Generate full text from sentences for response
            full_text = " ".join(sentences) if sentences else ""
            current_sentence = self._get_sentence_by_index(sentences, db_session.current_sentence_index)
            
            return WritingSessionResponse(
                id=db_session.id,
                user_id=db_session.user_id,
                topic=db_session.topic,
                level=db_session.level,
                total_sentences=db_session.total_sentences,
                current_sentence_index=db_session.current_sentence_index,
                status=db_session.status,
                vietnamese_text=full_text,
                vietnamese_sentences=sentences,
                current_sentence=current_sentence,
                created_at=db_session.created_at,
                updated_at=db_session.updated_at
            )
            
        except Exception as e:
            db.rollback()
            raise HTTPException(status_code=500, detail=f"Lỗi khi tạo phiên luyện viết: {str(e)}")
    
    async def get_writing_session(self, session_id: int, user_id: int, db: Session) -> Optional[WritingSessionResponse]:
        """Get a specific writing session"""
        session = db.query(WritingSession).filter(
            WritingSession.id == session_id,
            WritingSession.user_id == user_id
        ).first()
        
        if not session:
            return None
        
        # Get sentences from session state if available, otherwise use fallback
        try:
            agent_session = await self.session_service.get_session(
                app_name="WritingPractice",
                user_id=str(user_id),
                session_id=str(session_id)
            )
            
            # Read from vietnamese_sentences (dict with full_text and sentences)
            vietnamese_sentences_data = agent_session.state.get("vietnamese_sentences")
            if isinstance(vietnamese_sentences_data, dict):
                vietnamese_sentences = vietnamese_sentences_data.get("sentences", [])
            elif isinstance(vietnamese_sentences_data, list):
                vietnamese_sentences = vietnamese_sentences_data
            else:
                # Fallback: use from database
                vietnamese_sentences = self._parse_sentences_from_db(session.vietnamese_sentences)
                
        except Exception as e:
            print(f"Error getting sentences from state: {e}")
            # Try to get from database with parsing
            vietnamese_sentences = self._parse_sentences_from_db(session.vietnamese_sentences)
        
        # Generate full text from sentences for response
        full_text = " ".join(vietnamese_sentences) if vietnamese_sentences else ""
        current_sentence = self._get_sentence_by_index(vietnamese_sentences, session.current_sentence_index)
        
        return WritingSessionResponse(
            id=session.id,
            user_id=session.user_id,
            topic=session.topic,
            level=session.level,
            total_sentences=session.total_sentences,
            current_sentence_index=session.current_sentence_index,
            status=session.status,
            vietnamese_text=full_text,
            vietnamese_sentences=vietnamese_sentences,
            current_sentence=current_sentence,
            created_at=session.created_at,
            updated_at=session.updated_at
        )
    
    def get_user_writing_sessions(self, user_id: int, db: Session) -> List[WritingSessionListResponse]:
        """Get all writing sessions for a user"""
        sessions = db.query(WritingSession).filter(
            WritingSession.user_id == user_id
        ).order_by(desc(WritingSession.created_at)).all()
        
        return [
            WritingSessionListResponse(
                id=session.id,
                topic=session.topic,
                level=session.level,
                total_sentences=session.total_sentences,
                current_sentence_index=session.current_sentence_index,
                status=session.status,
                created_at=session.created_at
            )
            for session in sessions
        ]
    
    def delete_writing_session(self, session_id: int, user_id: int, db: Session) -> bool:
        """Delete a writing session"""
        session = db.query(WritingSession).filter(
            WritingSession.id == session_id,
            WritingSession.user_id == user_id
        ).first()
        
        if not session:
            return False
            
        db.delete(session)
        db.commit()
        return True
    
    def complete_writing_session(self, session_id: int, user_id: int, db: Session) -> bool:
        """Complete a writing session"""
        session = db.query(WritingSession).filter(
            WritingSession.id == session_id,
            WritingSession.user_id == user_id
        ).first()
        
        if not session:
            return False
            
        session.status = SessionStatus.COMPLETED
        db.commit()
        return True
    
    async def send_chat_message(
        self, 
        session_id: int, 
        user_id: int, 
        message_data: ChatMessageCreate, 
        db: Session
    ) -> ChatMessageResponse:
        """Send a chat message and get agent response"""
        try:
            # Get session
            session = db.query(WritingSession).filter(
                WritingSession.id == session_id,
                WritingSession.user_id == user_id
            ).first()
            
            if not session:
                raise HTTPException(status_code=404, detail=SESSION_NOT_FOUND_MSG)
            
            # Save user message
            user_message = WritingChatMessage(
                session_id=session_id,
                role="user",
                content=message_data.content,
                sentence_index=session.current_sentence_index
            )
            db.add(user_message)
            db.commit()
            
            # Get current Vietnamese sentence from state
            try:
                agent_session = await self.session_service.get_session(
                    app_name="WritingPractice",
                    user_id=str(user_id),
                    session_id=str(session_id)
                )
                state = agent_session.state or {}
                vietnamese_sentences_data = state.get("vietnamese_sentences", {})
                current_sentence_index = state.get("current_sentence_index", session.current_sentence_index)
                
                if isinstance(vietnamese_sentences_data, dict) and "sentences" in vietnamese_sentences_data:
                    sentences_list = vietnamese_sentences_data.get("sentences", [])
                    current_vietnamese_sentence = self._get_sentence_by_index(sentences_list, current_sentence_index)
                else:
                    current_vietnamese_sentence = None
            except Exception as e:
                logger.warning(f"Error getting current sentence from state: {e}")
                current_vietnamese_sentence = None
            
            # Build query with current Vietnamese sentence
            if current_vietnamese_sentence:
                query = f"""Câu tiếng Việt hiện tại cần dịch: {current_vietnamese_sentence}

Người dùng gửi: {message_data.content}"""
            else:
                query = message_data.content
            
            # Get agent response with logging (chat agent)
            runner = Runner(
                agent=chat_writing_agent,
                app_name="WritingPractice",
                session_service=self.session_service
            )
            
            agent_response = await call_agent_with_logging(
                runner=runner,
                user_id=str(user_id),
                session_id=str(session_id),
                query=query,
                logger=logger
            )
            db.refresh(session)
            # Save agent response
            agent_message = WritingChatMessage(
                session_id=session_id,
                role="assistant",
                content=agent_response,
                sentence_index=session.current_sentence_index
            )
            db.add(agent_message)
            
            # Update sentence index will be handled by agent tools
            
            db.commit()
            
            # Update session if needed
            db.refresh(session)
            
            return ChatMessageResponse(
                id=agent_message.id,
                session_id=agent_message.session_id,
                role=agent_message.role,
                content=agent_message.content,
                sentence_index=agent_message.sentence_index,
                status=session.status,
                created_at=agent_message.created_at
            )
            
        except Exception as e:
            db.rollback()
            raise ValueError(f"Error sending chat message: {str(e)}")
    
    def get_chat_history(self, session_id: int, user_id: int, db: Session) -> List[ChatMessageResponse]:
        """Get chat history for a session"""
        # Verify session belongs to user
        session = db.query(WritingSession).filter(
            WritingSession.id == session_id,
            WritingSession.user_id == user_id
        ).first()
        
        if not session:
            return []
        
        messages = db.query(WritingChatMessage).filter(
            WritingChatMessage.session_id == session_id
        ).order_by(WritingChatMessage.created_at).all()
        
        return [
            ChatMessageResponse(
                id=msg.id,
                session_id=msg.session_id,
                role=msg.role,
                content=msg.content,
                sentence_index=msg.sentence_index,
                status=session.status,
                created_at=msg.created_at
            )
            for msg in messages
        ]
    
    async def get_translation_hint(self, session_id: int, user_id: int, db: Session) -> HintResponse:
        """Get translation hint for current sentence"""
        try:
            # Get session
            session = db.query(WritingSession).filter(
                WritingSession.id == session_id,
                WritingSession.user_id == user_id
            ).first()
            
            if not session:
                raise HTTPException(status_code=404, detail=SESSION_NOT_FOUND_MSG)
            
            # Get agent session (should already exist)
            agent_session = await self.session_service.get_session(
                app_name="WritingPractice",
                user_id=str(user_id),
                session_id=str(session_id)
            )
            
            state = agent_session.state or {}
            hint_history = state.get("hint_history", {})
            current_sentence_index = state.get("current_sentence_index", session.current_sentence_index)
            level = state.get("level", session.level.value if hasattr(session.level, "value") else str(session.level))
            topic = state.get("topic", session.topic)
            
            # Get current Vietnamese sentence from vietnamese_sentences (dict)
            vietnamese_sentences_data = state.get("vietnamese_sentences")
            if isinstance(vietnamese_sentences_data, dict) and "sentences" in vietnamese_sentences_data:
                sentences_list = vietnamese_sentences_data.get("sentences", [])
                current_sentence = self._get_sentence_by_index(sentences_list, current_sentence_index)
            else:
                # Fallback: try old format (separate sentences key)
                sentences = state.get("sentences", [])
                if sentences and isinstance(sentences, list):
                    current_sentence = self._get_sentence_by_index(sentences, current_sentence_index)
                else:
                    # Fallback: get from database
                    db_sentences = self._parse_sentences_from_db(session.vietnamese_sentences)
                    current_sentence = self._get_sentence_by_index(db_sentences, current_sentence_index)
            
            if not current_sentence:
                raise HTTPException(status_code=400, detail="Không có câu hiện tại để gợi ý")
            
            # Check if hint already exists in history
            cached_hint = hint_history.get(str(current_sentence_index))
            if cached_hint and isinstance(cached_hint, str):
                return HintResponse(
                    hint=cached_hint,
                    sentence_index=current_sentence_index
                )
            
            # Get hint from agent
            runner = Runner(
                agent=hint_provider_agent,
                app_name="WritingPractice",
                session_service=self.session_service
            )
            
            # Build query with all necessary information
            query = f"""Tạo gợi ý dịch cho câu tiếng Việt sau:
Câu tiếng Việt: {current_sentence}
Chủ đề: {topic}
Độ khó (CEFR level): {level}"""
            
            try:
                hint_response = await call_agent_with_logging(
                    runner=runner,
                    user_id=str(user_id),
                    session_id=str(session_id),
                    query=query,
                    logger=logger
                )
            except Exception as agent_error:
                logger.error(f"Error calling hint agent: {agent_error}")
                raise HTTPException(status_code=500, detail=f"Lỗi khi gọi agent tạo gợi ý: {str(agent_error)}")
            
            # Read hint from state after agent finishes
            try:
                agent_session_after = await self.session_service.get_session(
                    app_name="WritingPractice",
                    user_id=str(user_id),
                    session_id=str(session_id)
                )
                state_after = agent_session_after.state or {}
                hint_history_after = state_after.get("hint_history", {})
                
                final_hint = hint_history_after.get(str(current_sentence_index))
                
                if not final_hint:
                    # Try with int key as fallback
                    final_hint = hint_history_after.get(current_sentence_index)
                
                if not final_hint:
                    final_hint = hint_response or ""
            except Exception as state_error:
                logger.error(f"Error reading state after agent run: {state_error}")
                final_hint = hint_response or ""
            
            if not isinstance(final_hint, str) or not final_hint.strip():
                logger.error(f"Invalid hint: type={type(final_hint)}, value={final_hint}")
                raise HTTPException(status_code=502, detail="Không có gợi ý hợp lệ được tạo bởi AI")

            return HintResponse(
                hint=final_hint,
                sentence_index=current_sentence_index
            )
            
        except HTTPException:
            raise
        except Exception as e:
            # Log the full error for debugging
            logger.error(f"Error in get_translation_hint: {type(e).__name__}: {e}", exc_info=True)
            # Map common ADK error to 404
            msg = str(e) if e else "Unknown error"
            if "Session not found" in msg:
                raise HTTPException(status_code=404, detail="Không tìm thấy phiên làm việc của agent")
            raise HTTPException(status_code=500, detail=f"Lỗi khi lấy gợi ý: {msg}")
    
    async def get_final_evaluation(self, session_id: int, user_id: int, db: Session) -> FinalEvaluationResponse:
        """Get final evaluation for completed session"""
        try:
            # Get session
            session = db.query(WritingSession).filter(
                WritingSession.id == session_id,
                WritingSession.user_id == user_id
            ).first()
            
            if not session:
                raise HTTPException(status_code=404, detail=SESSION_NOT_FOUND_MSG)
            
            # Get final evaluation from agent with logging
            runner = Runner(
                agent=final_evaluator_agent,
                app_name="WritingPractice",
                session_service=self.session_service
            )
            
            evaluation_response = await call_agent_with_logging(
                runner=runner,
                user_id=str(user_id),
                session_id=str(session_id),
                query="Generate final evaluation for this writing session",
                logger=logger
            )
            
            # Get structured output from agent session state
            try:
                # Get the structured output from the agent's session state
                agent_session = await self.session_service.get_session(
                    app_name="WritingPractice",
                    user_id=str(user_id),
                    session_id=str(session_id)
                )
                
                # Extract structured evaluation from session state
                final_eval = agent_session.state.get("final_evaluation", {})
                
                if final_eval:
                    overall = float(final_eval.get("overall_score", 0))
                    accuracy = float(final_eval.get("accuracy_score", 0))
                    fluency = float(final_eval.get("fluency_score", 0))
                    vocabulary = float(final_eval.get("vocabulary_score", 0))
                    grammar = float(final_eval.get("grammar_score", 0))
                    feedback = str(final_eval.get("feedback", ""))
                    suggestions = final_eval.get("suggestions", [])
                    if not isinstance(suggestions, list):
                        suggestions = []
                else:
                    # Fallback if no structured output
                    overall = 0.0
                    accuracy = 0.0
                    fluency = 0.0
                    vocabulary = 0.0
                    grammar = 0.0
                    feedback = evaluation_response
                    suggestions = []
                    
            except Exception as e:
                print(f"Error getting structured output: {e}")
                # Fallback to zeros
                overall = 0.0
                accuracy = 0.0
                fluency = 0.0
                vocabulary = 0.0
                grammar = 0.0
                feedback = evaluation_response
                suggestions = []

            return FinalEvaluationResponse(
                session_id=session_id,
                total_sentences=session.total_sentences,
                completed_sentences=session.current_sentence_index,
                overall_score=overall,
                accuracy_score=accuracy,
                fluency_score=fluency,
                vocabulary_score=vocabulary,
                grammar_score=grammar,
                feedback=feedback,
                suggestions=suggestions,
                completed_at=datetime.now()
            )
            
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Lỗi khi lấy đánh giá: {str(e)}")
    
    
    def _get_sentence_by_index(self, sentences: List[str], index: int) -> Optional[str]:
        """Get sentence at specific index from sentences array"""
        if 0 <= index < len(sentences):
            return sentences[index]
        return None
    
    def _parse_sentences_from_db(self, db_sentences) -> List[str]:
        """Parse sentences from database (handles both list and JSON string for backward compatibility)"""
        if not db_sentences:
            return []
        
        # If it's already a list (ARRAY type), return it
        if isinstance(db_sentences, list):
            return db_sentences
        
        # If it's a string (JSON string from old format), parse it
        if isinstance(db_sentences, str):
            try:
                parsed = json.loads(db_sentences)
                if isinstance(parsed, list):
                    return parsed
            except (json.JSONDecodeError, TypeError):
                pass
        
        return []
    
    def _get_sentences_from_db(self, session: WritingSession) -> List[str]:
        """Get sentences array from database session"""
        return self._parse_sentences_from_db(session.vietnamese_sentences)
    

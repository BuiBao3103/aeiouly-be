"""
Service layer for Writing Practice module
"""

from typing import List, Optional
from sqlalchemy.orm import Session
from sqlalchemy import desc
from src.writing.models import WritingSession, WritingChatMessage, SessionStatus, CEFRLevel
from src.writing.schemas import (
    WritingSessionCreate, 
    WritingSessionResponse, 
    WritingSessionListResponse,
    ChatMessageCreate, 
    ChatMessageResponse, 
    HintResponse, 
    FinalEvaluationResponse
)
from src.writing.agents.text_generator_agent.agent import text_generator_agent
from src.writing.agents.hint_provider_agent.agent import hint_provider_agent
from src.writing.agents.final_evaluator_agent.agent import final_evaluator_agent
from google.adk.runners import Runner
from google.adk.sessions import DatabaseSessionService
from google.genai import types
from datetime import datetime
import json
from src.config import get_database_url
from src.utils.agent_utils import call_agent_with_logging
import logging

# Constants
SESSION_NOT_FOUND_MSG = "Session not found"

# Logger for writing service
logger = logging.getLogger(__name__)

class WritingService:
    def __init__(self):
        # Use application DB config so ADK session tables live in the same PostgreSQL database
        self.session_service = DatabaseSessionService(db_url=get_database_url())
    
    async def create_writing_session(
        self, 
        user_id: int, 
        session_data: WritingSessionCreate, 
        db: Session
    ) -> WritingSessionResponse:
        """Create a new writing practice session"""
        try:
            # Create database session
            db_session = WritingSession(
                user_id=user_id,
                topic=session_data.topic,
                level=session_data.level,
                total_sentences=session_data.total_sentences,
                vietnamese_text="",  # Will be generated by agent
                status=SessionStatus.ACTIVE
            )
            
            db.add(db_session)
            db.commit()
            db.refresh(db_session)
            
            # Initialize agent session
            await self.session_service.create_session(
                app_name="WritingPractice",
                user_id=str(user_id),
                session_id=str(db_session.id),
                state={
                    "session_id": db_session.id,
                    "topic": session_data.topic,
                    "level": session_data.level.value,
                    "total_sentences": session_data.total_sentences,
                    "current_sentence_index": 0,
                    "vietnamese_text": "",
                    "current_sentence": "",
                    "evaluation_history": [],
                    "hint_history": [],
                    "current_time": datetime.now().isoformat()
                }
            )
            
            # Generate Vietnamese text using agent
            runner = Runner(
                agent=text_generator_agent,
                app_name="WritingPractice",
                session_service=self.session_service
            )
            
            # Run agent to generate text with logging
            generated_text = ""
            try:
                query = f"Generate Vietnamese text for topic: {session_data.topic}, level: {session_data.level.value}, sentences: {session_data.total_sentences}"
                
                generated_text = await call_agent_with_logging(
                    runner=runner,
                    user_id=str(user_id),
                    session_id=str(db_session.id),
                    query=query,
                    logger=logger
                )
                
                # If no text generated, raise error
                if not generated_text:
                    print("No text generated by agent")
                    raise ValueError("AI text generation failed: No content generated by agent")
                else:
                    # Get structured output from agent session state
                    try:
                        agent_session = await self.session_service.get_session(
                            app_name="WritingPractice",
                            user_id=str(user_id),
                            session_id=str(db_session.id)
                        )
                        
                        # Extract structured text from session state
                        vietnamese_result = agent_session.state.get("vietnamese_text", {})
                        
                        if vietnamese_result and isinstance(vietnamese_result, dict):
                            generated_text = vietnamese_result.get("full_text", generated_text)
                            vietnamese_sentences = vietnamese_result.get("sentences", [])
                            if not vietnamese_sentences:
                                vietnamese_sentences = [generated_text]
                        else:
                            vietnamese_sentences = [generated_text]
                            
                    except Exception as e:
                        print(f"Error getting structured output: {e}")
                        vietnamese_sentences = [generated_text]
                    
            except Exception as agent_error:
                print(f"Agent error: {agent_error}")
                import traceback
                traceback.print_exc()
                # Raise error instead of using fallback
                raise ValueError(f"AI text generation failed: {str(agent_error)}")
            
            # Update database with generated text
            db_session.vietnamese_text = generated_text
            db_session.current_sentence = self._get_sentence_by_index(vietnamese_sentences, 0)
            db.commit()
            
            # create first assistant message
            assistant_message = WritingChatMessage(
                session_id=db_session.id,
                role="assistant",
                content=f"Hãy dịch câu tiếng Việt này sang tiếng Anh: {vietnamese_sentences[0]}",
                sentence_index=0
            )
            db.add(assistant_message)
            db.commit()
            
            return WritingSessionResponse(
                id=db_session.id,
                user_id=db_session.user_id,
                topic=db_session.topic,
                level=db_session.level,
                total_sentences=db_session.total_sentences,
                current_sentence_index=db_session.current_sentence_index,
                status=db_session.status,
                vietnamese_text=db_session.vietnamese_text,
                vietnamese_sentences=vietnamese_sentences,
                current_sentence=db_session.current_sentence,
                created_at=db_session.created_at,
                updated_at=db_session.updated_at
            )
            
        except Exception as e:
            db.rollback()
            raise ValueError(f"Error creating writing session: {str(e)}")
    
    async def get_writing_session(self, session_id: int, user_id: int, db: Session) -> Optional[WritingSessionResponse]:
        """Get a specific writing session"""
        session = db.query(WritingSession).filter(
            WritingSession.id == session_id,
            WritingSession.user_id == user_id
        ).first()
        
        if not session:
            return None
            
        # Get sentences from structured output if available, otherwise use fallback
        try:
            agent_session = await self.session_service.get_session(
                app_name="WritingPractice",
                user_id=str(user_id),
                session_id=str(session_id)
            )
            
            vietnamese_result = agent_session.state.get("vietnamese_text", {})
            if vietnamese_result and isinstance(vietnamese_result, dict):
                vietnamese_sentences = vietnamese_result.get("sentences", [])
                if not vietnamese_sentences:
                    vietnamese_sentences = [session.vietnamese_text]
            else:
                vietnamese_sentences = [session.vietnamese_text]
                
        except Exception as e:
            print(f"Error getting structured output: {e}")
            vietnamese_sentences = [session.vietnamese_text]
        
        return WritingSessionResponse(
            id=session.id,
            user_id=session.user_id,
            topic=session.topic,
            level=session.level,
            total_sentences=session.total_sentences,
            current_sentence_index=session.current_sentence_index,
            status=session.status,
            vietnamese_text=session.vietnamese_text,
            vietnamese_sentences=vietnamese_sentences,
            current_sentence=session.current_sentence,
            created_at=session.created_at,
            updated_at=session.updated_at
        )
    
    def get_user_writing_sessions(self, user_id: int, db: Session) -> List[WritingSessionListResponse]:
        """Get all writing sessions for a user"""
        sessions = db.query(WritingSession).filter(
            WritingSession.user_id == user_id
        ).order_by(desc(WritingSession.created_at)).all()
        
        return [
            WritingSessionListResponse(
                id=session.id,
                topic=session.topic,
                level=session.level,
                total_sentences=session.total_sentences,
                current_sentence_index=session.current_sentence_index,
                status=session.status,
                created_at=session.created_at
            )
            for session in sessions
        ]
    
    def delete_writing_session(self, session_id: int, user_id: int, db: Session) -> bool:
        """Delete a writing session"""
        session = db.query(WritingSession).filter(
            WritingSession.id == session_id,
            WritingSession.user_id == user_id
        ).first()
        
        if not session:
            return False
            
        db.delete(session)
        db.commit()
        return True
    
    def complete_writing_session(self, session_id: int, user_id: int, db: Session) -> bool:
        """Complete a writing session"""
        session = db.query(WritingSession).filter(
            WritingSession.id == session_id,
            WritingSession.user_id == user_id
        ).first()
        
        if not session:
            return False
            
        session.status = SessionStatus.COMPLETED
        db.commit()
        return True
    
    async def send_chat_message(
        self, 
        session_id: int, 
        user_id: int, 
        message_data: ChatMessageCreate, 
        db: Session
    ) -> ChatMessageResponse:
        """Send a chat message and get agent response"""
        try:
            # Get session
            session = db.query(WritingSession).filter(
                WritingSession.id == session_id,
                WritingSession.user_id == user_id
            ).first()
            
            if not session:
                raise ValueError(SESSION_NOT_FOUND_MSG)
            
            # Save user message
            user_message = WritingChatMessage(
                session_id=session_id,
                role="user",
                content=message_data.content,
                sentence_index=session.current_sentence_index
            )
            db.add(user_message)
            db.commit()
            
            # Get agent response with logging
            runner = Runner(
                agent=text_generator_agent,
                app_name="WritingPractice",
                session_service=self.session_service
            )
            
            agent_response = await call_agent_with_logging(
                runner=runner,
                user_id=str(user_id),
                session_id=str(session_id),
                query=message_data.content,
                logger=logger
            )
            
            # Save agent response
            agent_message = WritingChatMessage(
                session_id=session_id,
                role="assistant",
                content=agent_response,
                sentence_index=session.current_sentence_index
            )
            db.add(agent_message)
            
            # Update sentence index will be handled by agent tools
            
            db.commit()
            
            # Update session if needed
            db.refresh(session)
            
            return ChatMessageResponse(
                id=agent_message.id,
                session_id=agent_message.session_id,
                role=agent_message.role,
                content=agent_message.content,
                sentence_index=agent_message.sentence_index,
                status=session.status,
                created_at=agent_message.created_at
            )
            
        except Exception as e:
            db.rollback()
            raise ValueError(f"Error sending chat message: {str(e)}")
    
    def get_chat_history(self, session_id: int, user_id: int, db: Session) -> List[ChatMessageResponse]:
        """Get chat history for a session"""
        # Verify session belongs to user
        session = db.query(WritingSession).filter(
            WritingSession.id == session_id,
            WritingSession.user_id == user_id
        ).first()
        
        if not session:
            return []
        
        messages = db.query(WritingChatMessage).filter(
            WritingChatMessage.session_id == session_id
        ).order_by(WritingChatMessage.created_at).all()
        
        return [
            ChatMessageResponse(
                id=msg.id,
                session_id=msg.session_id,
                role=msg.role,
                content=msg.content,
                sentence_index=msg.sentence_index,
                status=session.status,
                created_at=msg.created_at
            )
            for msg in messages
        ]
    
    async def get_translation_hint(self, session_id: int, user_id: int, db: Session) -> HintResponse:
        """Get translation hint for current sentence"""
        try:
            # Get session
            session = db.query(WritingSession).filter(
                WritingSession.id == session_id,
                WritingSession.user_id == user_id
            ).first()
            
            if not session:
                raise ValueError(SESSION_NOT_FOUND_MSG)
            
            # Get current sentence from database
            current_sentence = session.current_sentence
            
            if not current_sentence:
                raise ValueError("No current sentence available")
            
            # Get hint from agent with logging
            runner = Runner(
                agent=hint_provider_agent,
                app_name="WritingPractice",
                session_service=self.session_service
            )
            
            hint_response = await call_agent_with_logging(
                runner=runner,
                user_id=str(user_id),
                session_id=str(session_id),
                query=f"Provide hint for: {current_sentence}",
                logger=logger
            )
            
            return HintResponse(
                hint=hint_response,
                sentence_index=session.current_sentence_index
            )
            
        except Exception as e:
            raise ValueError(f"Error getting translation hint: {str(e)}")
    
    async def get_final_evaluation(self, session_id: int, user_id: int, db: Session) -> FinalEvaluationResponse:
        """Get final evaluation for completed session"""
        try:
            # Get session
            session = db.query(WritingSession).filter(
                WritingSession.id == session_id,
                WritingSession.user_id == user_id
            ).first()
            
            if not session:
                raise ValueError(SESSION_NOT_FOUND_MSG)
            
            # Get final evaluation from agent with logging
            runner = Runner(
                agent=final_evaluator_agent,
                app_name="WritingPractice",
                session_service=self.session_service
            )
            
            evaluation_response = await call_agent_with_logging(
                runner=runner,
                user_id=str(user_id),
                session_id=str(session_id),
                query="Generate final evaluation for this writing session",
                logger=logger
            )
            
            # Get structured output from agent session state
            try:
                # Get the structured output from the agent's session state
                agent_session = await self.session_service.get_session(
                    app_name="WritingPractice",
                    user_id=str(user_id),
                    session_id=str(session_id)
                )
                
                # Extract structured evaluation from session state
                final_eval = agent_session.state.get("final_evaluation", {})
                
                if final_eval:
                    overall = float(final_eval.get("overall_score", 0))
                    accuracy = float(final_eval.get("accuracy_score", 0))
                    fluency = float(final_eval.get("fluency_score", 0))
                    vocabulary = float(final_eval.get("vocabulary_score", 0))
                    grammar = float(final_eval.get("grammar_score", 0))
                    feedback = str(final_eval.get("feedback", ""))
                    suggestions = final_eval.get("suggestions", [])
                    if not isinstance(suggestions, list):
                        suggestions = []
                else:
                    # Fallback if no structured output
                    overall = 0.0
                    accuracy = 0.0
                    fluency = 0.0
                    vocabulary = 0.0
                    grammar = 0.0
                    feedback = evaluation_response
                    suggestions = []
                    
            except Exception as e:
                print(f"Error getting structured output: {e}")
                # Fallback to zeros
                overall = 0.0
                accuracy = 0.0
                fluency = 0.0
                vocabulary = 0.0
                grammar = 0.0
                feedback = evaluation_response
                suggestions = []

            return FinalEvaluationResponse(
                session_id=session_id,
                total_sentences=session.total_sentences,
                completed_sentences=session.current_sentence_index,
                overall_score=overall,
                accuracy_score=accuracy,
                fluency_score=fluency,
                vocabulary_score=vocabulary,
                grammar_score=grammar,
                feedback=feedback,
                suggestions=suggestions,
                completed_at=datetime.now()
            )
            
        except Exception as e:
            raise ValueError(f"Error getting final evaluation: {str(e)}")
    
    
    def _get_sentence_by_index(self, sentences: List[str], index: int) -> Optional[str]:
        """Get sentence at specific index from sentences array"""
        if 0 <= index < len(sentences):
            return sentences[index]
        return None
    
